package com.walking.intensive.chapter2.task8;

/**
 * Добираясь в школу на трамвае Вова проверяет, является ли купленный билет счастливым.
 * Если является, то нужно загадать желание и съесть билетик.
 *
 * <p>Билет содержит 6 цифр, комбинации подбираются случайным образом от 000000 до 999999.
 *
 * <p>Билет считается счастливым, если сумма первых трех цифр равна сумме последних трех цифр.
 *
 * <p>Пример: 123411 – счастливый (1 + 2 + 3 == 4 + 1 + 1).
 *
 * <p>Реализуйте метод getHappyTicketChance(), который будет возвращать вероятность
 * выпадения счастливого билета.
 *
 * <p>P.S. Вероятность – это отношение благоприятных исходов к числу всех исходов.
 * Вероятность не может принимать значение больше 1.
 *
 * <p><a href="https://github.com/KFalcon2022/intensive-tasks-2024/blob/master/README.md">Требования к оформлению</a>
 */
public class Task8 {
    public static void main(String[] args) {
//        Для собственных проверок можете делать любые изменения в этом методе
    }

    static double getHappyTicketChance() {
        int[] countOfSums = new int[28];
        // В методе мы перебираем все возможные суммы трёх первых и трёх последних цифр билета.
        // Нетрудно догадаться, что максимальная сумма трёх цифр будет 27, т.к. 9+9+9 = 27.
        // Также к 27 вариантам добавляется 0, хоть и такой билет у нас всего один.
        // Получается, что всего возможных сумм у нас 28, такой размер массива мы и выбираем.

        for (int i = 0; i <= 9; i++) {      // этими тремя строками мы перебираем все варианты трёх чисел
            for (int j = 0; j <= 9; j++) {     // от нуля до девятки
                for (int k = 0; k <= 9; k++) {
                    int sum = i + j + k;
                    countOfSums[sum]++; // и добавляем соответствующему элементу массива 1, если сумма совпадает
                }                       // с индексом массива
            }
        }
        long happyTicketCount = 0;
        for (int sum = 0; sum <= 27; sum++) {
            happyTicketCount += (long) countOfSums[sum] * countOfSums[sum];
            //Для каждой суммы от 0 до 27 количество комбинаций для первой половины
        } // билета умножается на количество комбинаций для второй половины (так как они должны быть равны).

        final long totalTickets = 1_000_000L; // дано по условию

        return (double) happyTicketCount / totalTickets; //непосредственно вычисление вероятности

    }
}
